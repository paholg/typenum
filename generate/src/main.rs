use std::fs::File;
use std::io::Write;
use std::path::{Path, PathBuf};
use std::{env, fmt};

mod generic_const_mappings;
mod op;

enum UIntCode {
    Term,
    Zero(Box<UIntCode>),
    One(Box<UIntCode>),
}

impl fmt::Display for UIntCode {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        match *self {
            UIntCode::Term => write!(f, "UTerm"),
            UIntCode::Zero(ref inner) => write!(f, "UInt<{}, B0>", inner),
            UIntCode::One(ref inner) => write!(f, "UInt<{}, B1>", inner),
        }
    }
}

fn gen_uint(u: u64) -> UIntCode {
    let mut result = UIntCode::Term;
    let mut x = 1u64 << 63;
    while x > u {
        x >>= 1
    }
    while x > 0 {
        result = if x & u > 0 {
            UIntCode::One(Box::new(result))
        } else {
            UIntCode::Zero(Box::new(result))
        };
        x >>= 1;
    }
    result
}

const HIGHEST: u64 = 1024;
fn uints() -> impl Iterator<Item = u64> {
    let first2: u32 = (HIGHEST as f64).log(2.0).round() as u32 + 1;
    let first10: u32 = (HIGHEST as f64).log(10.0) as u32 + 1;
    (0..(HIGHEST + 1))
        .chain((first2..64).map(|i| 2u64.pow(i)))
        .chain((first10..20).map(|i| 10u64.pow(i)))
}

fn gen_consts() -> String {
    let mut result = String::new();
    // Header stuff here!
    result.push_str(&format!(
        "
#![allow(missing_docs)]
/**
Type aliases for many constants.

This file is generated by typenum's build script.

For unsigned integers, the format is `U` followed by the number. We define aliases for

- Numbers 0 through {highest}
- Powers of 2 below `u64::MAX`
- Powers of 10 below `u64::MAX`

These alias definitions look like this:

```rust
use typenum::{{B0, B1, UInt, UTerm}};

# #[allow(dead_code)]
type U6 = UInt<UInt<UInt<UTerm, B1>, B1>, B0>;
```

For positive signed integers, the format is `P` followed by the number and for negative
signed integers it is `N` followed by the number. For the signed integer zero, we use
`Z0`. We define aliases for

- Numbers -{highest} through {highest}
- Powers of 2 between `i64::MIN` and `i64::MAX`
- Powers of 10 between `i64::MIN` and `i64::MAX`

These alias definitions look like this:

```rust
use typenum::{{B0, B1, UInt, UTerm, PInt, NInt}};

# #[allow(dead_code)]
type P6 = PInt<UInt<UInt<UInt<UTerm, B1>, B1>, B0>>;
# #[allow(dead_code)]
type N6 = NInt<UInt<UInt<UInt<UTerm, B1>, B1>, B0>>;
```

# Example
```rust
# #[allow(unused_imports)]
use typenum::{{U0, U1, U2, U3, U4, U5, U6}};
# #[allow(unused_imports)]
use typenum::{{N3, N2, N1, Z0, P1, P2, P3}};
# #[allow(unused_imports)]
use typenum::{{U774, N17, N10000, P1024, P4096}};
```

We also define the aliases `False` and `True` for `B0` and `B1`, respectively.
*/
use crate::uint::{{UInt, UTerm}};
use crate::int::{{PInt, NInt}};

pub use crate::bit::{{B0, B1}};
pub use crate::int::Z0;

pub type True = B1;
pub type False = B0;
",
        highest = HIGHEST,
    ));

    for u in uints() {
        result.push_str(&format!("pub type U{} = {};\n", u, gen_uint(u)));
        if u <= ::std::i64::MAX as u64 && u != 0 {
            let i = u as i64;
            result.push_str(&format!(
                "pub type P{i} = PInt<U{i}>;\npub type N{i} = NInt<U{i}>;\n",
                i = i
            ));
        }
    }
    result
}

const HEADER: &str = "// THIS IS GENERATED CODE";

fn main() {
    let manifest_dir: PathBuf = env::var("CARGO_MANIFEST_DIR").unwrap().into();
    let out_dir = manifest_dir.join("../src/gen/");

    let files = [
        ("consts.rs", gen_consts()),
        ("op.rs", op::gen_op_macro()),
        (
            "generic_const_mappings.rs",
            generic_const_mappings::emit_impls(),
        ),
    ];

    for (fname, contents) in files {
        let dest = Path::new(&out_dir).join(fname);

        let mut f = File::create(&dest).unwrap();
        f.write_all(HEADER.as_bytes()).unwrap();
        f.write_all(contents.as_bytes()).unwrap();
    }
}
